import * as nls from 'vscode-nls';
const localize = nls.config({ messageFormat: nls.MessageFormat.file })();
import * as vscode from 'vscode';
import { DatabaseManager } from "./modules/database";
import { StatusBarManager } from "./modules/statusBar";
import { timeTrace } from "./modules/timeTrace";
import { StatsManager } from "./modules/stats";
import { CommandManager } from "./modules/commands";
import { getConfig } from "./modules/config";
import { PomodoroManager } from "./modules/pomodoro";
import { ModalManager } from "./modules/modal";
import { FocusCompleteModal } from "./ui/focusCompleteModal";
import { PomodoroSettingsModal } from "./ui/pomodoroSettingsModal";
import { SoundManager, SoundType, SoundTheme } from "./modules/soundManager";
import { VisualState } from "./modules/visualEffectsManager";
import { DesktopNotificationManager } from "./modules/desktopNotifications";

// Vari√°veis globais para gerenciar a extens√£o
let globalContext: vscode.ExtensionContext | null = null;
let dbManager: DatabaseManager;
let statusBarManager: StatusBarManager;
let myTimeTrace: timeTrace;
let statsManager: StatsManager;
let pomodoroManager: PomodoroManager;
let modalManager: ModalManager;
let focusCompleteModal: FocusCompleteModal;
let pomodoroSettingsModal: PomodoroSettingsModal;
let soundManager: SoundManager;
let desktopNotificationManager: DesktopNotificationManager;

// Ativa√ß√£o da extens√£o
export async function activate(context: vscode.ExtensionContext) {
  globalContext = context;
  
  // Logs de ativa√ß√£o
  console.log("=======================================");
  console.log(localize('extension.activated', 'Extension "my-time-trace-vscode" activated!'));
  console.log("Vers√£o: 0.2.1");
  console.log("Data/Hora: " + new Date().toISOString());
  console.log("=======================================");

  // Inicializa os m√≥dulos
  try {
    // Inicializa o banco de dados
    dbManager = new DatabaseManager();
    await dbManager.initialize(context.globalStorageUri.fsPath);

    // Inicializa os gerenciadores
    statusBarManager = new StatusBarManager();
    myTimeTrace = new timeTrace(dbManager, statusBarManager);
    statsManager = new StatsManager(dbManager);
    
    // Inicializa o Modal Manager
    modalManager = ModalManager.getInstance();
    modalManager.initialize(context);
    
    // Inicializa o Sound Manager
    soundManager = SoundManager.getInstance();
    soundManager.initialize(context);
    
    // Inicializa o Desktop Notification Manager
    desktopNotificationManager = DesktopNotificationManager.getInstance();
    desktopNotificationManager.initialize(context);
    
    // Inicializa o Pomodoro Manager com refer√™ncia ao timeTrace
    pomodoroManager = new PomodoroManager(dbManager, statusBarManager, myTimeTrace);
    await pomodoroManager.initialize();

    // Inicializa o Focus Complete Modal
    focusCompleteModal = FocusCompleteModal.getInstance();
    focusCompleteModal.initialize(pomodoroManager);

    // Inicializa o Pomodoro Settings Modal
    pomodoroSettingsModal = PomodoroSettingsModal.getInstance();
    pomodoroSettingsModal.initialize(pomodoroManager);

    // Conecta eventos do Pomodoro com Modals e Notifica√ß√µes
    pomodoroManager.setEvents({
      onFocusStart: async (duration: number) => {
        // Notifica√ß√£o de in√≠cio de foco
        if (pomodoroManager.getConfig()?.enableDesktopNotifications) {
          await desktopNotificationManager.showFocusStartNotification(duration);
        }
      },
      onFocusComplete: async () => {
        // Disparar modal quando foco completa (45 minutos)
        await focusCompleteModal.showFocusCompleteAlert({
          focusDuration: 45, // minutos
          canContinue: true,
          continueMinutes: 5
        });
        
        // Notifica√ß√£o de foco completo
        if (pomodoroManager.getConfig()?.enableDesktopNotifications) {
          await desktopNotificationManager.showFocusCompleteNotification(45);
        }
      },
      onBreakStart: async (duration: number, type: 'short' | 'long') => {
        // Notifica√ß√£o de in√≠cio de pausa
        if (pomodoroManager.getConfig()?.enableDesktopNotifications) {
          await desktopNotificationManager.showBreakStartNotification(duration);
        }
      },
      onBreakComplete: async () => {
        // Notifica√ß√£o de fim de pausa
        if (pomodoroManager.getConfig()?.enableDesktopNotifications) {
          await desktopNotificationManager.showBreakCompleteNotification();
        }
      }
    });

    // Cria e configura o status bar
    statusBarManager.create();

    // Registra os comandos
    const commands = CommandManager.registerCommands(
      () => myTimeTrace.startTracking(),
      () => myTimeTrace.pauseTracking(),
      () => statsManager.showStats(),
      // Comandos do Pomodoro
      () => pomodoroManager.startFocusSession(),
      () => pomodoroManager.pauseSession(),
      () => pomodoroManager.stopSession(),
      async () => {
        // Abrir configura√ß√µes avan√ßadas do Pomodoro
        await pomodoroSettingsModal.showSettings();
      }
    );

    // Comando adicional para iniciar break (usado pelas notifica√ß√µes)
    const startBreakCommand = CommandManager.safeRegisterCommand(
      'my-time-trace-vscode.startBreak',
      async () => {
        try {
          console.log('üü¢ Comando startBreak executado');
          await pomodoroManager.startBreakSession('short');
        } catch (error) {
          console.error('‚ùå Erro ao iniciar break:', error);
          vscode.window.showErrorMessage('Erro ao iniciar pausa');
        }
      }
    );

    // Comando de teste para modais (apenas durante desenvolvimento)
    const testModalCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testModal', async () => {
      try {
        // Teste b√°sico inline para validar sistema de modal
        const testConfig = {
          id: 'test-modal-basic',
          title: 'Teste Sistema Modal',
          content: `
            <div class="text-center">
              <div class="modal-icon">üß™</div>
              <h3>Sistema de Modal Base</h3>
              <p>TAREFA 1 - Sistema funcionando!</p>
            </div>
          `,
          buttons: [{
            id: 'ok',
            text: 'OK',
            primary: true,
            onClick: () => modalManager.closeModal('test-modal-basic')
          }],
          width: '400px',
          height: '300px'
        };
        
        await modalManager.showModal(testConfig);
        console.log('‚úÖ Teste de modal executado com sucesso');
      } catch (error) {
        console.error('‚ùå Erro ao testar modal:', error);
        vscode.window.showErrorMessage('Erro ao testar sistema de modais');
      }
    });
    
    // Comando de teste para Focus Complete Modal
    const testFocusModalCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testFocusCompleteModal', async () => {
      try {
        console.log('üß™ Testando Focus Complete Modal...');
        await focusCompleteModal.showFocusCompleteAlert({
          focusDuration: 45,
          canContinue: true,
          continueMinutes: 5
        });
        console.log('‚úÖ Focus Complete Modal testado com sucesso!');
      } catch (error) {
        console.error('‚ùå Erro ao testar Focus Complete Modal:', error);
        vscode.window.showErrorMessage('Erro ao testar Focus Complete Modal');
      }
    });
    
    // Comando de teste para integra√ß√£o autom√°tica (simular disparo real)
    const testPomodoroIntegrationCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testPomodoroIntegration', async () => {
      try {
        console.log('üîó Testando integra√ß√£o autom√°tica Pomodoro...');
        
        // Verificar se Pomodoro est√° configurado
        if (!pomodoroManager) {
          vscode.window.showErrorMessage('PomodoroManager n√£o inicializado');
          return;
        }
        
        // Simular evento de foco completo diretamente
        vscode.window.showInformationMessage('üß™ Simulando completar 45 minutos de foco...');
        
        // Aguardar 2 segundos para parecer real
        setTimeout(async () => {
          // Disparar evento manualmente para testar
          await focusCompleteModal.showFocusCompleteAlert({
            focusDuration: 45,
            canContinue: true,
            continueMinutes: 5
          });
          
          vscode.window.showInformationMessage('‚úÖ Teste de integra√ß√£o conclu√≠do! Modal deve ter aparecido automaticamente.');
        }, 2000);
        
      } catch (error) {
        console.error('‚ùå Erro ao testar integra√ß√£o:', error);
        vscode.window.showErrorMessage('Erro ao testar integra√ß√£o Pomodoro');
      }
    });
    
    // Comando para testar Pomodoro real com tempo acelerado (desenvolvimento)
    const testRealPomodoroCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testRealPomodoro', async () => {
      try {
        console.log('‚ö° Iniciando Pomodoro real com tempo acelerado...');
        
        if (!pomodoroManager) {
          vscode.window.showErrorMessage('PomodoroManager n√£o inicializado');
          return;
        }
        
        // Informar ao usu√°rio
        const choice = await vscode.window.showInformationMessage(
          '‚ö° Iniciar Pomodoro real com 10 segundos (em vez de 45 minutos) para testar integra√ß√£o?',
          'Sim, testar', 'Cancelar'
        );
        
        if (choice !== 'Sim, testar') {
          return;
        }
        
        // Modificar temporariamente a configura√ß√£o para teste r√°pido
        const originalConfig = pomodoroManager.getConfig();
        if (originalConfig) {
          await pomodoroManager.updateConfig({
            focusDuration: 0.1, // 6 segundos em vez de 45 minutos para teste r√°pido
            shortBreakDuration: 0.1, // 6 segundos tamb√©m
            autoStartBreaks: true
          });
        }
        
        // Iniciar sess√£o de foco
        await pomodoroManager.startFocusSession();
        
        vscode.window.showInformationMessage(
          '‚è±Ô∏è Pomodoro iniciado! O modal deve aparecer automaticamente em ~6 segundos. Certifique-se de estar codificando para ativar o timer.',
          'OK'
        );
        
      } catch (error) {
        console.error('‚ùå Erro ao testar Pomodoro real:', error);
        vscode.window.showErrorMessage('Erro ao iniciar Pomodoro de teste');
      }
    });
    
    // Comando de teste para configura√ß√µes do Pomodoro
    const testPomodoroSettingsCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testPomodoroSettings', async () => {
      try {
        console.log('‚öôÔ∏è Testando configura√ß√µes do Pomodoro...');
        await pomodoroSettingsModal.showSettings();
        console.log('‚úÖ Modal de configura√ß√µes testado com sucesso!');
      } catch (error) {
        console.error('‚ùå Erro ao testar configura√ß√µes:', error);
        vscode.window.showErrorMessage('Erro ao testar configura√ß√µes do Pomodoro');
      }
    });
    
    // Comando de teste para notifica√ß√µes autom√°ticas do Pomodoro
    const testPomodoroAutoNotificationsCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testPomodoroAutoNotifications', async () => {
      try {
        console.log('üîî Testando notifica√ß√µes autom√°ticas do Pomodoro...');
        
        vscode.window.showInformationMessage(
          'üß™ Iniciando teste de notifica√ß√µes autom√°ticas. Voc√™ ver√° notifica√ß√µes quando eventos do Pomodoro acontecerem.',
          'Iniciar Teste'
        );
        
        // Habilitar notifica√ß√µes temporariamente para o teste
        await pomodoroManager.updateConfig({
          enableDesktopNotifications: true,
          focusDuration: 0.1, // 6 segundos para teste r√°pido
          shortBreakDuration: 0.1 // 6 segundos para teste r√°pido
        });
        
        console.log('üìã Configura√ß√£o tempor√°ria aplicada (6s para foco e pausa)');
        
        // Aguardar 1 segundo e iniciar sess√£o
        setTimeout(async () => {
          console.log('üéØ Iniciando sess√£o de foco (deve disparar notifica√ß√£o)...');
          await pomodoroManager.startFocusSession();
          
          // Ap√≥s 7 segundos, iniciar pausa
          setTimeout(async () => {
            console.log('‚òï Iniciando pausa (deve disparar notifica√ß√£o)...');
            await pomodoroManager.startBreakSession('short');
            
            // Ap√≥s mais 7 segundos, mostrar resultado
            setTimeout(() => {
              console.log('‚úÖ Teste de notifica√ß√µes autom√°ticas conclu√≠do!');
              vscode.window.showInformationMessage(
                '‚úÖ Teste conclu√≠do! Voc√™ deve ter visto 4 notifica√ß√µes: in√≠cio foco, fim foco, in√≠cio pausa, fim pausa.',
                'OK'
              );
              
              // Restaurar configura√ß√µes padr√£o
              pomodoroManager.updateConfig({
                focusDuration: 45,
                shortBreakDuration: 15
              });
            }, 8000);
          }, 7000);
        }, 1000);
        
      } catch (error) {
        console.error('‚ùå Erro ao testar notifica√ß√µes autom√°ticas:', error);
        vscode.window.showErrorMessage('Erro ao testar notifica√ß√µes autom√°ticas do Pomodoro');
      }
    });
    
    // Comando de teste para sistema de sons
    const testSoundSystemCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testSoundSystem', async () => {
      try {
        console.log('üîä Testando sistema de sons...');
        
        // Listar temas dispon√≠veis
        const themes = soundManager.getAvailableThemes();
        const themeNames = themes.map(t => t.name);
        
        const selectedTheme = await vscode.window.showQuickPick(themeNames, {
          placeHolder: 'Selecione um tema de som para testar'
        });
        
        if (!selectedTheme) {
          return;
        }
        
        const theme = themes.find(t => t.name === selectedTheme)?.theme;
        if (!theme) {
          return;
        }
        
        // Testar sons do tema
        vscode.window.showInformationMessage(`üéµ Testando tema: ${selectedTheme}`);
        
        await soundManager.previewSound('focus_complete' as any, theme);
        
        setTimeout(async () => {
          await soundManager.previewSound('notification' as any, theme);
        }, 1000);
        
        console.log('‚úÖ Sistema de sons testado com sucesso!');
      } catch (error) {
        console.error('‚ùå Erro ao testar sistema de sons:', error);
        vscode.window.showErrorMessage('Erro ao testar sistema de sons');
      }
    });
    
    // Comando de teste para sons sint√©ticos
    const testSyntheticSoundsCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testSyntheticSounds', async () => {
      try {
        console.log('üéµ Testando sons sint√©ticos...');
        vscode.window.showInformationMessage('üéµ Iniciando teste completo de sons sint√©ticos...');
        
        await soundManager.testSyntheticSounds();
        
        vscode.window.showInformationMessage('‚úÖ Teste de sons sint√©ticos conclu√≠do! Verifique o console.');
        console.log('‚úÖ Teste de sons sint√©ticos conclu√≠do com sucesso!');
      } catch (error) {
        console.error('‚ùå Erro ao testar sons sint√©ticos:', error);
        vscode.window.showErrorMessage('Erro ao testar sons sint√©ticos');
      }
    });
    
    // Comando de teste para sons especiais (DTMF e beeps)
    const testSpecialSoundsCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testSpecialSounds', async () => {
      try {
        console.log('üîî Testando sons especiais...');
        vscode.window.showInformationMessage('üîî Testando DTMF e sequ√™ncias de beeps...');
        
        await soundManager.testSpecialSounds();
        
        vscode.window.showInformationMessage('‚úÖ Teste de sons especiais conclu√≠do! Verifique o console.');
        console.log('‚úÖ Teste de sons especiais conclu√≠do com sucesso!');
      } catch (error) {
        console.error('‚ùå Erro ao testar sons especiais:', error);
        vscode.window.showErrorMessage('Erro ao testar sons especiais');
      }
    });

    // Comando de teste para arquivos WAV reais
    const testWavSoundsCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testWavSounds', async () => {
      try {
        console.log('üéµ Testando arquivos WAV...');
        vscode.window.showInformationMessage('üéµ Testando arquivos WAV musicais...');
        
        const soundTypes = [
          SoundType.FOCUS_START,
          SoundType.FOCUS_COMPLETE,
          SoundType.NOTIFICATION,
          SoundType.SUCCESS
        ];
        
        for (const soundType of soundTypes) {
          vscode.window.showInformationMessage(`üéµ Reproduzindo: ${soundType}`);
          console.log(`üéµ Testando som: ${soundType}`);
          
          await soundManager.playSound(soundType, { 
            force: true, 
            volume: 60,
            theme: SoundTheme.CLASSIC 
          });
          
          // Pausa entre sons
          await new Promise(resolve => setTimeout(resolve, 1500));
        }
        
        vscode.window.showInformationMessage('‚úÖ Teste de arquivos WAV conclu√≠do!');
        console.log('‚úÖ Teste de arquivos WAV conclu√≠do com sucesso!');
      } catch (error) {
        console.error('‚ùå Erro ao testar arquivos WAV:', error);
        vscode.window.showErrorMessage(`‚ùå Erro ao testar arquivos WAV: ${error}`);
      }
    });

    // Comando de teste para efeitos visuais
    const testVisualEffectsCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testVisualEffects', async () => {
      try {
        console.log('üé® Testando efeitos visuais...');
        vscode.window.showInformationMessage('üé® Iniciando teste de efeitos visuais...');
        
        const visualEffects = statusBarManager.getVisualEffects();
        
        // Teste de estados visuais com valores enum corretos
        const states = [
          { state: VisualState.FOCUS_ACTIVE, message: 'üéØ Modo Foco Ativo' },
          { state: VisualState.FOCUS_ENDING, message: '‚ö° Foco Terminando' },
          { state: VisualState.BREAK_ACTIVE, message: '‚òï Intervalo Ativo' },
          { state: VisualState.SUCCESS, message: '‚úÖ Sucesso!' },
          { state: VisualState.WARNING, message: '‚ö†Ô∏è Aten√ß√£o!' },
          { state: VisualState.NOTIFICATION, message: 'üîî Notifica√ß√£o' }
        ];
        
        for (const { state, message } of states) {
          vscode.window.showInformationMessage(`üé® Testando: ${message}`);
          
          // Aplicar estado visual
          statusBarManager.setVisualState(state, {
            animated: true,
            duration: 1000,
            message: message
          });
          
          // Aguardar visualiza√ß√£o
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
        
        // Teste de notifica√ß√£o flash
        vscode.window.showInformationMessage('üé® Testando notifica√ß√µes flash...');
        
        statusBarManager.showNotificationFlash('Informa√ß√£o', 'info');
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        statusBarManager.showNotificationFlash('Sucesso', 'success');
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        statusBarManager.showNotificationFlash('Aviso', 'warning');
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        statusBarManager.showNotificationFlash('Erro', 'error');
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Teste de pulsa√ß√£o
        vscode.window.showInformationMessage('üé® Testando efeito de pulsa√ß√£o...');
        statusBarManager.startPulseEffect(VisualState.FOCUS_ACTIVE, 500);
        
        await new Promise(resolve => setTimeout(resolve, 5000));
        
        statusBarManager.stopPulseEffect();
        
        // Voltar ao estado idle
        statusBarManager.setVisualState(VisualState.IDLE);
        
        vscode.window.showInformationMessage('‚úÖ Teste de efeitos visuais conclu√≠do!');
        console.log('‚úÖ Teste de efeitos visuais conclu√≠do com sucesso!');
      } catch (error) {
        console.error('‚ùå Erro ao testar efeitos visuais:', error);
        vscode.window.showErrorMessage(`‚ùå Erro ao testar efeitos visuais: ${error}`);
      }
    });
    
    // Comando de preview de som com sele√ß√£o de tipo e tema
    const previewSoundCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.previewSound', async () => {
      try {
        // Selecionar tipo de som
        const soundTypes = [
          { label: 'üéØ In√≠cio do Foco', value: 'focus_start' },
          { label: '‚úÖ Foco Completo', value: 'focus_complete' },
          { label: '‚òï In√≠cio do Intervalo', value: 'break_start' },
          { label: 'üéâ Intervalo Completo', value: 'break_complete' },
          { label: 'üîî Notifica√ß√£o', value: 'notification' },
          { label: '‚ö†Ô∏è Aviso', value: 'warning' },
          { label: '‚ú® Sucesso', value: 'success' },
          { label: '‚ùå Erro', value: 'error' }
        ];
        
        const selectedType = await vscode.window.showQuickPick(soundTypes, {
          placeHolder: 'Selecione o tipo de som para preview'
        });
        
        if (!selectedType) {
          return;
        }
        
        // Selecionar tema
        const themes = soundManager.getAvailableThemes();
        const themeOptions = themes.map(t => ({
          label: `üé® ${t.name}`,
          description: t.description,
          value: t.theme
        }));
        
        const selectedTheme = await vscode.window.showQuickPick(themeOptions, {
          placeHolder: 'Selecione o tema de som'
        });
        
        if (!selectedTheme) {
          return;
        }
        
        vscode.window.showInformationMessage(`üéß Preview: ${selectedType.label} (${selectedTheme.label})`);
        
        await soundManager.previewSoundWithTheme(selectedType.value as any, selectedTheme.value as any);
        
        console.log(`‚úÖ Preview executado: ${selectedType.value} (${selectedTheme.value})`);
      } catch (error) {
        console.error('‚ùå Erro no preview de som:', error);
        vscode.window.showErrorMessage('Erro no preview de som');
      }
    });
    
    // Comando de teste para sons reais com Web Audio API
    const testRealAudioCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testRealAudio', async () => {
      try {
        console.log('üéµ Testando reprodu√ß√£o real de √°udio...');
        
        const choice = await vscode.window.showInformationMessage(
          'üéµ Testar sons reais com Web Audio API? (Isso abrir√° um painel oculto para reproduzir sons)',
          'Sim, testar', 'Cancelar'
        );
        
        if (choice !== 'Sim, testar') {
          return;
        }
        
        vscode.window.showInformationMessage('üéµ Iniciando teste de sons reais...');
        
        // Testar sequ√™ncia de sons
        const soundTypes = ['focus_start', 'focus_complete', 'notification', 'success'];
        const theme = 'classic';
        
        for (let i = 0; i < soundTypes.length; i++) {
          const soundType = soundTypes[i];
          vscode.window.showInformationMessage(`üéµ Reproduzindo: ${soundType} (${i + 1}/${soundTypes.length})`);
          
          try {
            await soundManager.previewSoundWithTheme(soundType as any, theme as any);
            console.log(`‚úÖ Som reproduzido: ${soundType}`);
          } catch (error) {
            console.error(`‚ùå Erro no som ${soundType}:`, error);
          }
          
          // Pausa entre sons
          if (i < soundTypes.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 1500));
          }
        }
        
        vscode.window.showInformationMessage('‚úÖ Teste de sons reais conclu√≠do! Voc√™ ouviu algum som?');
        console.log('‚úÖ Teste de sons reais conclu√≠do!');
      } catch (error) {
        console.error('‚ùå Erro ao testar sons reais:', error);
        vscode.window.showErrorMessage('Erro ao testar sons reais');
      }
    });
    
    // Comando de teste para beeps do sistema (m√©todo mais direto)
    const testSystemBeepsCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testSystemBeeps', async () => {
      try {
        console.log('üîî Testando beeps do sistema...');
        
        const choice = await vscode.window.showInformationMessage(
          'üîî Testar beeps reais do sistema operacional? Voc√™ deve ouvir uma sequ√™ncia de sons.',
          'Sim, testar beeps', 'Cancelar'
        );
        
        if (choice !== 'Sim, testar beeps') {
          return;
        }
        
        vscode.window.showInformationMessage('üîî Testando 1 beep...');
        await soundManager.testSpecialSounds();
        
        vscode.window.showInformationMessage('‚úÖ Teste de beeps conclu√≠do! Voc√™ ouviu os beeps?');
        console.log('‚úÖ Teste de beeps do sistema conclu√≠do!');
      } catch (error) {
        console.error('‚ùå Erro ao testar beeps do sistema:', error);
        vscode.window.showErrorMessage('Erro ao testar beeps do sistema');
      }
    });
    
    // Comando de teste para notifica√ß√µes desktop
    const testDesktopNotificationsCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testDesktopNotifications', async () => {
      try {
        console.log('üîî Testando notifica√ß√µes desktop...');
        
        const choice = await vscode.window.showInformationMessage(
          'üîî Testar sistema completo de notifica√ß√µes desktop?',
          'Sim, testar', 'Cancelar'
        );
        
        if (choice !== 'Sim, testar') {
          return;
        }
        
        vscode.window.showInformationMessage('üîî Iniciando teste de notifica√ß√µes desktop...');
        
        await desktopNotificationManager.testNotificationSystem();
        
        vscode.window.showInformationMessage('‚úÖ Teste de notifica√ß√µes desktop conclu√≠do!');
        console.log('‚úÖ Teste de notifica√ß√µes desktop conclu√≠do com sucesso!');
      } catch (error) {
        console.error('‚ùå Erro ao testar notifica√ß√µes desktop:', error);
        vscode.window.showErrorMessage('Erro ao testar notifica√ß√µes desktop');
      }
    });
    
    // Comando de teste espec√≠fico para notifica√ß√µes do Pomodoro
    const testPomodoroNotificationsCommand = CommandManager.safeRegisterCommand('my-time-trace-vscode.testPomodoroNotifications', async () => {
      try {
        console.log('üçÖ Testando notifica√ß√µes do Pomodoro...');
        
        const notificationTypes = [
          { label: 'üéØ Foco Completo (45 min)', action: () => desktopNotificationManager.showFocusCompleteNotification(45) },
          { label: '‚òï In√≠cio da Pausa (5 min)', action: () => desktopNotificationManager.showBreakStartNotification(5) },
          { label: '‚ö° Pausa Terminada', action: () => desktopNotificationManager.showBreakCompleteNotification() },
          { label: 'üéâ Pomodoro Completo (4 ciclos)', action: () => desktopNotificationManager.showPomodoroCompleteNotification(4) }
        ];
        
        const selectedType = await vscode.window.showQuickPick(notificationTypes, {
          placeHolder: 'Selecione o tipo de notifica√ß√£o do Pomodoro para testar'
        });
        
        if (!selectedType) {
          return;
        }
        
        vscode.window.showInformationMessage(`üîî Testando: ${selectedType.label}`);
        
        await selectedType.action();
        
        console.log(`‚úÖ Notifica√ß√£o testada: ${selectedType.label}`);
      } catch (error) {
        console.error('‚ùå Erro ao testar notifica√ß√µes do Pomodoro:', error);
        vscode.window.showErrorMessage('Erro ao testar notifica√ß√µes do Pomodoro');
      }
    });
    
    commands.push(startBreakCommand);
    commands.push(testModalCommand);
    commands.push(testFocusModalCommand);
    commands.push(testPomodoroIntegrationCommand);
    commands.push(testRealPomodoroCommand);
    commands.push(testPomodoroSettingsCommand);
    commands.push(testPomodoroAutoNotificationsCommand);
    commands.push(testSoundSystemCommand);
    commands.push(testSyntheticSoundsCommand);
    commands.push(testSpecialSoundsCommand);
    commands.push(testWavSoundsCommand);
    commands.push(testVisualEffectsCommand);
    commands.push(previewSoundCommand);
    commands.push(testRealAudioCommand);
    commands.push(testSystemBeepsCommand);
    commands.push(testDesktopNotificationsCommand);
    commands.push(testPomodoroNotificationsCommand);

    // Registra os eventos para monitoramento
    const eventEditorChange = vscode.window.onDidChangeActiveTextEditor((editor) => {
      myTimeTrace.onActiveEditorChange(editor);
      // Notificar Pomodoro sobre atividade
      pomodoroManager.onUserActivity();
    });

    const eventTextChange = vscode.workspace.onDidChangeTextDocument((event) => {
      myTimeTrace.onTextDocumentChange(event);
      // Notificar Pomodoro sobre atividade
      pomodoroManager.onUserActivity();
    });

    const eventWindowStateChange = vscode.window.onDidChangeWindowState((windowState) => {
      myTimeTrace.onWindowStateChange(windowState);
      // Notificar Pomodoro sobre atividade se janela estiver focada
      if (windowState.focused) {
        pomodoroManager.onUserActivity();
      }
    });

    // Adiciona todos os subscriptions ao contexto
    context.subscriptions.push(...commands);
    context.subscriptions.push(eventEditorChange);
    context.subscriptions.push(eventTextChange);
    context.subscriptions.push(eventWindowStateChange);

    // Adiciona handlers de limpeza
    context.subscriptions.push({
      dispose: () => {
        myTimeTrace.dispose();
      },
    });

    context.subscriptions.push({
      dispose: () => {
        statusBarManager.dispose();
      },
    });

    context.subscriptions.push({
      dispose: () => {
        pomodoroManager.dispose();
      },
    });

    context.subscriptions.push({
      dispose: () => {
        modalManager.dispose();
      },
    });

    context.subscriptions.push({
      dispose: () => {
        soundManager.dispose();
      },
    });

    context.subscriptions.push({
      dispose: () => {
        desktopNotificationManager.dispose();
      },
    });

    // Auto-iniciar se configurado
    const userConfig = getConfig();
    if (userConfig.autoStart) {
      setTimeout(() => {
        if (!myTimeTrace.isCurrentlyTracking()) {
          vscode.commands.executeCommand("my-time-trace-vscode.startTracking");
        }
      }, 100);
    }

  } catch (error) {
    console.error("Falha ao inicializar a extens√£o:", error);
    vscode.window.showErrorMessage(
      localize('extension.initializationFailed', 'Time Tracking: Failed to initialize the extension.')
    );
  }
}

// Desativa√ß√£o da extens√£o
export function deactivate() {
  console.log("=======================================");
  console.log(localize('extension.deactivated', 'Extension "my-time-trace-vscode" deactivated!'));
  console.log("Data/Hora: " + new Date().toISOString());
  console.log("=======================================");

  // Limpa os recursos
  if (myTimeTrace) {
    myTimeTrace.dispose();
  }

  if (statusBarManager) {
    statusBarManager.dispose();
  }

  if (dbManager) {
    dbManager.close().catch((err) => {
      console.error("Erro ao fechar banco de dados:", err);
    });
  }

  // Limpa a refer√™ncia ao contexto global
  globalContext = null;
}
